1
0:00:15,039 --> 0:00:17,689
the usual way to get a large computer

2
0:00:17,689 --> 0:00:21,890
application developed involves a big

3
0:00:21,890 --> 0:00:23,810
team of people working in close

4
0:00:23,810 --> 0:00:27,439
coordination most of the time this works

5
0:00:27,439 --> 0:00:29,810
surprisingly well but it does have its

6
0:00:29,810 --> 0:00:34,760
problems and large projects tend to get

7
0:00:34,760 --> 0:00:38,930
done poorly they take a long time they

8
0:00:38,930 --> 0:00:40,550
consume an astonishing amount of money

9
0:00:40,550 --> 0:00:43,879
and in many cases the individual team

10
0:00:43,879 --> 0:00:46,429
members are dissatisfied so everybody in

11
0:00:46,429 --> 0:00:48,230
the computing business is constantly

12
0:00:48,230 --> 0:00:51,050
searching for ways to do a better job of

13
0:00:51,050 --> 0:00:55,280
developing computer applications there

14
0:00:55,280 --> 0:00:57,339
aren't likely to be any final answers

15
0:00:57,339 --> 0:01:00,079
both because the problems are hard and

16
0:01:00,079 --> 0:01:02,510
because as we find solutions we try even

17
0:01:02,510 --> 0:01:05,810
more ambitious objectives but there are

18
0:01:05,810 --> 0:01:07,310
some things that can be done to make

19
0:01:07,310 --> 0:01:09,080
life easier for everybody on a large

20
0:01:09,080 --> 0:01:12,320
programming project a good programming

21
0:01:12,320 --> 0:01:15,590
environment helps a lot and in the next

22
0:01:15,590 --> 0:01:18,080
few minutes we're going to show you some

23
0:01:18,080 --> 0:01:19,670
of the properties of the UNIX operating

24
0:01:19,670 --> 0:01:22,280
system that make it a good programming

25
0:01:22,280 --> 0:01:25,790
environment for many purposes in Bell

26
0:01:25,790 --> 0:01:28,250
Labs as in many industries almost

27
0:01:28,250 --> 0:01:30,320
everyone has some kind of involvement

28
0:01:30,320 --> 0:01:32,690
with software either they are actually

29
0:01:32,690 --> 0:01:34,700
producing software and that is their job

30
0:01:34,700 --> 0:01:38,510
or they are impacted by software or they

31
0:01:38,510 --> 0:01:41,180
use software fact that Bell Labs about

32
0:01:41,180 --> 0:01:43,400
50% of the people are actually producing

33
0:01:43,400 --> 0:01:45,740
software and everyone else has some kind

34
0:01:45,740 --> 0:01:46,940
of involvement with it

35
0:01:46,940 --> 0:01:49,130
in fact that's one of our worse problems

36
0:01:49,130 --> 0:01:52,220
today there is a crying need for useful

37
0:01:52,220 --> 0:01:55,640
software to do effective jobs we just do

38
0:01:55,640 --> 0:01:57,170
not have enough people for write all

39
0:01:57,170 --> 0:02:00,260
that software keeping large amounts of

40
0:02:00,260 --> 0:02:02,420
software working and keeping it working

41
0:02:02,420 --> 0:02:04,700
in the face of change is a big job takes

42
0:02:04,700 --> 0:02:07,550
a lot of skilled people to do this now

43
0:02:07,550 --> 0:02:10,970
software is different from hardware when

44
0:02:10,970 --> 0:02:13,190
you build hardware and send it out

45
0:02:13,190 --> 0:02:15,709
you may have to fix it because it breaks

46
0:02:15,709 --> 0:02:18,830
but you don't demand for example that

47
0:02:18,830 --> 0:02:20,360
your radio suddenly turn into a

48
0:02:20,360 --> 0:02:22,670
television and you don't demand that a

49
0:02:22,670 --> 0:02:24,290
piece of hardware suddenly do a

50
0:02:24,290 --> 0:02:26,450
completely different function but people

51
0:02:26,450 --> 0:02:27,830
do that of software all

52
0:02:27,830 --> 0:02:30,890
the time there's a continual demand for

53
0:02:30,890 --> 0:02:34,670
changes enhancements new features that

54
0:02:34,670 --> 0:02:36,980
people find necessary once they get used

55
0:02:36,980 --> 0:02:39,080
to a system in other words we put the

56
0:02:39,080 --> 0:02:41,180
system out there people get used to it

57
0:02:41,180 --> 0:02:43,730
their jobs change they come back with

58
0:02:43,730 --> 0:02:45,590
more demands for different sorts of

59
0:02:45,590 --> 0:02:48,860
features in the system the result is

60
0:02:48,860 --> 0:02:50,390
there's no way to get perfect

61
0:02:50,390 --> 0:02:52,760
requirements in the first place and that

62
0:02:52,760 --> 0:02:54,290
means that we have to build the software

63
0:02:54,290 --> 0:02:57,380
to be very changed tolerant because we

64
0:02:57,380 --> 0:02:59,270
do not want to throw the software away

65
0:02:59,270 --> 0:03:01,880
the year after we wrote it there are a

66
0:03:01,880 --> 0:03:04,760
couple ways to do that one is to make

67
0:03:04,760 --> 0:03
the software fairly clear and easy to

68
0:03 --> 0:03:10,760
read and understand and change and you

69
0:03:10,760 --> 0:03:12,920
do that with some of the current popular

70
0:03:12,920 --> 0:03:14,620
structured programming techniques

71
0:03:14,620 --> 0:03:18,320
another way is to write many many small

72
0:03:18,320 --> 0:03:20,930
modules of code that way when you have a

73
0:03:20,930 --> 0:03:23,630
change perhaps you only throw out a few

74
0:03:23,630 --> 0:03:25,940
small modules or make changes in a few

75
0:03:25,940 --> 0:03:28,370
modules rather than in thousands and

76
0:03:28,370 --> 0:03:30,650
thousands of lines of code what we

77
0:03:30,650 --> 0:03:32,360
should be doing in the computing

78
0:03:32,360 --> 0:03:34,820
business is trying to raise the level at

79
0:03:34,820 --> 0:03:37,160
which we work so that a programmer can

80
0:03:37,160 --> 0:03:40,250
write a few lines of code that turn into

81
0:03:40,250 --> 0:03:42,320
many many instructions in the machine

82
0:03:42,320 --> 0:03:44,780
that way when changes need to be made

83
0:03:44,780 --> 0:03:46,850
one just changes a few lines of code

84
0:03:46,850 --> 0:03:49,340
rather than thousands and thousands of

85
0:03:49,340 --> 0:03:52,160
them in the mythical man-month

86
0:03:52,160 --> 0:03:54,950
fred brooks estimates that it took 5,000

87
0:03:54,950 --> 0:03:56,930
staff years of effort to produce the

88
0:03:56,930 --> 0:03:59,390
operating system for IBM's 360 series

89
0:03:59,390 --> 0:04:02,750
computers clearly nobody is going to do

90
0:04:02,750 --> 0:04:04,430
that sort of thing very often certainly

91
0:04:04,430 --> 0:04:06,200
not for every new type of hardware or

92
0:04:06,200 --> 0:04:08,620
for every new class of application

93
0:04:08,620 --> 0:04:11,209
someone once said that software stands

94
0:04:11,209 --> 0:04:13,310
between the user and the machine and to

95
0:04:13,310 --> 0:04:15,230
me this conveys this picture of a great

96
0:04:15,230 --> 0:04:17,209
wall of software up there that you have

97
0:04:17,209 --> 0:04:19,760
to overcome to get anything done there's

98
0:04:19,760 --> 0:04:21,109
certainly a grain of truth in the remark

99
0:04:21,109 --> 0:04:23,510
anyway if you stop to look many many

100
0:04:23,510 --> 0:04:25,250
operating systems seem to spend a

101
0:04:25,250 --> 0:04:27,860
substantial fraction of their time and

102
0:04:27,860 --> 0:04:30,140
effort not in helping you but in

103
0:04:30,140 --> 0:04:31,940
impeding you in making your job

104
0:04:31,940 --> 0:04:33,919
difficult sort of providing obstacles to

105
0:04:33,919 --> 0:04:36,169
be overcome when Ken Thompson and Dennis

106
0:04:36,169 --> 0:04:37,040
Ritchie start

107
0:04:37,040 --> 0:04:39,850
the unit system 1969

108
0:04:39,850 --> 0:04:42,720
they found a structure which simplified

109
0:04:42,720 --> 0:04:45,250
many aspects of the interactions between

110
0:04:45,250 --> 0:04:48,400
computers and people Thomson and Richie

111
0:04:48,400 --> 0:04:50,260
were aiming to keep their system simple

112
0:04:50,260 --> 0:04:52,180
and they found a collection of

113
0:04:52,180 --> 0:04:54,400
primitives that enable them to do a

114
0:04:54,400 --> 0:04:56,050
great deal with the very few primitives

115
0:04:56,050 --> 0:04:59,470
a UNIX system is made up sort of of

116
0:04:59,470 --> 0:05:01,420
three layers if you like the central

117
0:05:01,420 --> 0:05:03,550
layer the kernel is the thing that

118
0:05:03,550 --> 0:05:05,310
controls the resources of the machine

119
0:05:05,310 --> 0:05:08,100
then wrapped around that at least in

120
0:05:08,100 --> 0:05:10,180
conceptually is something called the

121
0:05:10,180 --> 0:05:12,160
shell which is the interface between

122
0:05:12,160 --> 0:05:15,070
most users and the kernel part it sits

123
0:05:15,070 --> 0:05:16,360
there and waits for you to type commands

124
0:05:16,360 --> 0:05:18,280
at it and then it interprets them and

125
0:05:18,280 --> 0:05:20,020
then around that sort of an yet another

126
0:05:20,020 --> 0:05:22,720
layer are useful programs things like

127
0:05:22,720 --> 0:05:24,970
editors and compilers for programming

128
0:05:24,970 --> 0:05:26,800
languages and document formatting

129
0:05:26,800 --> 0:05:29,110
programs and programs that you write

130
0:05:29,110 --> 0:05:33,970
yourself and what you can do is to think

131
0:05:33,970 --> 0:05
of these UNIX system programs basically

132
0:05 --> 0:05:38,830
as in some sense the building blocks

133
0:05:38,830 --> 0:05:41,770
with which you can create things and the

134
0:05:41,770 --> 0:05:43,270
thing that distinguishes UNIX system

135
0:05:43,270 --> 0:05:45,400
from any other system is the degree to

136
0:05:45,400 --> 0:05:47,080
which those building blocks can be glued

137
0:05:47,080 --> 0:05:49,300
together in a variety of different ways

138
0:05:49,300 --> 0:05:51,250
not just obvious ways but in many cases

139
0:05:51,250 --> 0:05:54,070
very unobvious ways to get different

140
0:05:54,070 --> 0:05:57,220
jobs done the system is very flexible in

141
0:05:57,220 --> 0:05:59,110
that respect I think the notion of

142
0:05:59,110 --> 0:06:00,850
pipelining is the fundamental

143
0:06:00,850 --> 0:06:03,300
contribution if the system is you can

144
0:06:03,300 --> 0:06:06,580
take a bunch of programs two or more

145
0:06:06,580 --> 0:06:08,290
programs and stick them together end to

146
0:06:08,290 --> 0:06:10,150
end so that the data simply flows from

147
0:06:10,150 --> 0:06:11,470
the one on the left to the one on the

148
0:06:11,470 --> 0:06:13,840
right and the system itself looks after

149
0:06:13,840 --> 0:06:15,220
all the connections all of the

150
0:06:15,220 --> 0:06:17,170
synchronization making sure that the

151
0:06:17,170 --> 0:06:18,700
data goes from the one into the other

152
0:06:18,700 --> 0:06:21,010
the program's themselves don't know

153
0:06:21,010 --> 0:06:22,780
anything about the connection as far as

154
0:06:22,780 --> 0:06:23,830
they're concerned they're just talking

155
0:06:23,830 --> 0:06:25,390
to the terminal let me give you an

156
0:06:25,390 --> 0:06:29,190
example of how this works in practice

157
0:06:29,190 --> 0:06:32,230
the system is as I mentioned is used a

158
0:06:32,230 --> 0:06:34,810
lot for document preparation kinds of

159
0:06:34,810 --> 0:06:37,360
things programs for helping you type

160
0:06:37,360 --> 0:06:39,550
letters or produce technical papers or

161
0:06:39,550 --> 0:06:42,970
write books in all of those things of

162
0:06:42,970 --> 0:06:44,230
course people when they're typing into

163
0:06:44,230 --> 0:06:45,880
machine make spelling mistakes so let's

164
0:06:45,880 --> 0:06:47,050
see how we could use some of these

165
0:06:47,050 --> 0:06:48,880
building block notions in practice to

166
0:06:48,880 --> 0:06:51,070
help you develop a program for finding

167
0:06:51,070 --> 0:06:52,810
spelling mistakes suppose I take a

168
0:06:52,810 --> 0:06:53,590
sentence this is a

169
0:06:53,590 --> 0:06:57,160
sentence which is in a paper that John

170
0:06:57,160 --> 0:07:01,900
Massey and I wrote some years ago now if

171
0:07:01,900 --> 0:07:03,070
you look at it carefully you'll see that

172
0:07:03,070 --> 0:07:04,720
there are actually a couple of spelling

173
0:07:04,720 --> 0:07:07,120
mistakes in there now suppose that we

174
0:07:07,120 --> 0:07:08,710
wanted to find the spelling mistakes

175
0:07:08,710 --> 0:07:10,150
using a machine how would we do that

176
0:07:10,150 --> 0:07:12,790
well basically what we would do the

177
0:07:12,790 --> 0:07:14,080
simplest thing I can think of is to

178
0:07:14,080 --> 0:07:18,490
split the sentence there in two words

179
0:07:18,490 --> 0:07:20,170
individual words and then compare the

180
0:07:20,170 --> 0:07:22,030
words against a dictionary and every

181
0:07:22,030 --> 0:07:23,650
time we find a word which is in that

182
0:07:23,650 --> 0:07:25,270
sentence but not in dictionary it's at

183
0:07:25,270 --> 0:07:27,250
least a plausible contender for being a

184
0:07:27,250 --> 0:07:29,590
spelling mistake now how do we do that

185
0:07:29,590 --> 0:07:31,690
what I want to show is that you can do

186
0:07:31,690 --> 0:07:33,640
that using just existing UNIX programs

187
0:07:33,640 --> 0:07:35,410
just gluing them together to get the job

188
0:07:35,410 --> 0:07:38,080
done suppose that we say first we will

189
0:07:38,080 --> 0:07:40,770
take a program called make words and

190
0:07:40,770 --> 0:07:43,300
we'll run that on the sentence now what

191
0:07:43,300 --> 0:07:46,450
that does is break the thing up into one

192
0:07:46,450 --> 0:07:50,260
word per line now I'll take the output

193
0:07:50,260 --> 0:07:53,170
and I'll pipe it into another program

194
0:07:53,170 --> 0:07:54,490
which will simply convert it into

195
0:07:54,490 --> 0:07:56,200
lowercase the reason I want to convert

196
0:07:56,200 --> 0:07:57,850
it into lowercase is that my dictionary

197
0:07:57,850 --> 0:07:59,650
doesn't have any capitalizations and so

198
0:07:59,650 --> 0:08:02,260
words like Bell and UNIX which are

199
0:08:02,260 --> 0:08:03,730
capitalized here would show up as

200
0:08:03,730 --> 0:08:06,580
spelling mistakes unless I did this now

201
0:08:06,580 --> 0:08:08,320
the next thing that I want to do my

202
0:08:08,320 --> 0:08:09,880
dictionary is in fact sorted in

203
0:08:09,880 --> 0:08:12,010
alphabetical order dictionaries are and

204
0:08:12,010 --> 0:08:13,930
so it's a lot easier for me to compare

205
0:08:13,930 --> 0:08:16,690
the words of my document to the words in

206
0:08:16,690 --> 0:08:18,760
the dictionary if they're started so I'm

207
0:08:18,760 --> 0:08:25,480
going to run them into sort and finally

208
0:08:25,480 --> 0:08:26,710
if you look at it carefully it doesn't

209
0:08:26,710 --> 0:08:29,710
show up very easily here but there are

210
0:08:29,710 --> 0:08:32,350
in fact there is a duplicate word their

211
0:08:32,350 --> 0:08:35,050
systems appears twice and in a real

212
0:08:35,050 --> 0:08:36,970
document words like TIG would show up

213
0:08:36,970 --> 0:08:38,380
many times so we'd like to get rid of

214
0:08:38,380 --> 0:08:40,270
duplicates so let's throw that through

215
0:08:40,270 --> 0:08:43,720
another program called unique so what

216
0:08:43,720 --> 0:08:45,790
we've got so far is we've got the words

217
0:08:45,790 --> 0:08:47,590
of my document in this case the sentence

218
0:08:47,590 --> 0:08:51,130
one word per line in lowercase neatly

219
0:08:51,130 --> 0:08:52,930
sorted and all of the duplicate words

220
0:08:52,930 --> 0:08:55,390
thrown away so there's only one word one

221
0:08:55,390 --> 0:08:57,520
instance of each different word then

222
0:08:57,520 --> 0:08:58,930
what I'm going to do is run it into one

223
0:08:58,930 --> 0:09:01,300
last program called mismatch which will

224
0:09:01,300 --> 0:09:03,010
simply print all of the words that came

225
0:09:03,010 --> 0:09:05,540
down this pipeline and

226
0:09:05,540 --> 0:09:08,180
print out the ones that were in the

227
0:09:08,180 --> 0:09:10,810
document that word in the dictionary

228
0:09:10,810 --> 0:09:14,390
what we have here is five separate

229
0:09:14,390 --> 0:09:17,380
programs cooperating to do this job and

230
0:09:17,380 --> 0:09:20,990
in one giant pipeline now if you look at

231
0:09:20,990 --> 0:09:22,340
the list that came out you'll see that

232
0:09:22,340 --> 0:09:24,470
indeed we got laboratories and provide

233
0:09:24,470 --> 0:09:26,390
which were our two spelling mistakes of

234
0:09:26,390 --> 0:09:27,860
course we've got two other words as well

235
0:09:27,860 --> 0:09:30,290
and this tells you not only was what

236
0:09:30,290 --> 0:09:32,150
what's good about the approach but also

237
0:09:32,150 --> 0:09:34,850
what's bad about it time sharing is not

238
0:09:34,850 --> 0:09:36,560
a spelling mistake but it's a perfectly

239
0:09:36,560 --> 0:09:38,660
fine example of technical jargon the

240
0:09:38,660 --> 0:09:39,830
sort of thing that means something to

241
0:09:39,830 --> 0:09:41,570
everybody in the computer business it

242
0:09:41,570 --> 0:09:43,100
means nothing whatsoever to people who

243
0:09:43,100 --> 0:09:45,320
are not computer types and the word UNIX

244
0:09:45,320 --> 0:09:47,900
is a fine example of something that's

245
0:09:47,900 --> 0:09:49,220
not going to be found in a normal

246
0:09:49,220 --> 0:09:53,390
dictionary so what do we do first we

247
0:09:53,390 --> 0:09:55,550
take the misspelled words and we go back

248
0:09:55,550 --> 0:09:57,050
to the original document and we correct

249
0:09:57,050 --> 0:09:58,040
them so we don't have any spelling

250
0:09:58,040 --> 0:10:00,560
mistakes secondly we take the words that

251
0:10:00,560 --> 0:10:02,810
like time-sharing and unix that are not

252
0:10:02,810 --> 0:10:04,310
spelling mistakes but which showed up

253
0:10:04,310 --> 0:10:06,290
here and we put them back into our

254
0:10:06,290 --> 0:10:07,970
dictionary so that the next time

255
0:10:07,970 --> 0:10:09,860
somebody has a document that contains

256
0:10:09,860 --> 0:10:11,420
the UNIX or time-sharing they don't show

257
0:10:11,420 --> 0:10:13,250
up as spelling mistakes so we've not

258
0:10:13,250 --> 0:10:14,900
only done our own job but we've improved

259
0:10:14,900 --> 0:10:17,170
the tool that we're using in the process

260
0:10:17,170 --> 0:10:19,640
so you notice that I did that whole job

261
0:10:19,640 --> 0:10:21,650
without writing any programs at all the

262
0:10:21,650 --> 0:10:23,330
whole thing is cobbled together out of

263
0:10:23,330 --> 0:10:25,070
programs that already exist it and all I

264
0:10:25,070 --> 0:10:27,560
did was to use the fact that the system

265
0:10:27,560 --> 0:10:29,630
provides this mechanism of the pipeline

266
0:10:29,630 --> 0:10:31,190
so that I can take programs and stick

267
0:10:31,190 --> 0:10:33,020
them together one after another to get

268
0:10:33,020 --> 0:10:35,780
my job done and I think this is one of

269
0:10:35,780 --> 0:10:37,250
the reasons why the system so productive

270
0:10:37,250 --> 0:10:40,130
that there's a large collection of

271
0:10:40,130 --> 0:10:41,780
things that people have already built

272
0:10:41,780 --> 0:10:45,740
that we use and as we build our new

273
0:10:45,740 --> 0:10:47,060
things then they become part of the

274
0:10:47,060 --> 0:10:48,700
repertoire of things that people

275
0:10:48,700 --> 0:10:51,590
subsequently can build on during the

276
0:10:51,590 --> 0:10:54,140
last decade we have discovered a number

277
0:10:54,140 --> 0:10:56,980
of new powerful pattern matching

278
0:10:56,980 --> 0:10:59,480
algorithms that are useful for locating

279
0:10:59,480 --> 0:11
patterns and texts many of these

280
0:11 --> 0:11:05,030
algorithms have been developed using

281
0:11:05,030 --> 0:11:07,640
insights obtained from theory obtained

282
0:11:07,640 --> 0:11:09,770
by studying automata and language theory

283
0:11:09,770 --> 0:11:14,180
as our knowledge of pattern matching

284
0:11:14,180 --> 0:11:17,060
algorithms increases we can very quickly

285
0:11:17,060 --> 0:11:19,260
take this knowledge and

286
0:11:19,260 --> 0:11:21,390
package it in the form of UNIX programs

287
0:11:21,390 --> 0:11:25,050
and we can spread these UNIX programs to

288
0:11:25,050 --> 0:11:35,660
the entire community very quickly

289
0:11:35,660 --> 0:11:38,600
the UNIX systems has many features which

290
0:11:38,600 --> 0:11:41,060
make it easier for the programmer to

291
0:11:41,060 --> 0:11:42,170
write programs

292
0:11:42,170 --> 0:11:46,580
these include form atlas files the

293
0:11:46,580 --> 0:11:49,340
hierarchical directory structure the

294
0:11:49,340 --> 0:11:51,260
ability to pipeline the output of one

295
0:11:51,260 --> 0:11:55,070
command as the input of another device

296
0:11:55,070 --> 0:11:58,910
independent i/o all of these things make

297
0:11:58,910 --> 0:12:01,730
programming considerably easier than on

298
0:12:01,730 --> 0:12:04,790
most other systems the heart of the

299
0:12:04,790 --> 0:12:06,530
system is really the file system the

300
0:12:06,530 --> 0:12:08,540
ability to store information for

301
0:12:08,540 --> 0:12:11,240
extended periods of time and the reason

302
0:12:11,240 --> 0:12:12,890
one of the reasons the system works as

303
0:12:12,890 --> 0:12:14,750
well as it does is that the file system

304
0:12:14,750 --> 0:12:17,630
is well designed and many systems you

305
0:12:17,630 --> 0:12:19,220
have to say an awful lot about a file

306
0:12:19,220 --> 0:12:20,840
before you can do anything with it you

307
0:12:20,840 --> 0:12:23,030
have to say where it is and how big it

308
0:12:23,030 --> 0:12:24,770
is and what kind of information it's

309
0:12:24,770 --> 0:12:26,450
going to that's going to be in it

310
0:12:26,450 --> 0:12:27,980
all kinds of things that are basically

311
0:12:27,980 --> 0:12:30,620
utterly completely irrelevant here you

312
0:12:30,620 --> 0:12:32,480
don't have to do any of that the file is

313
0:12:32,480 --> 0:12
as big as it is it doesn't matter where

314
0:12 --> 0:12:36,200
it is as long as you know what it's

315
0:12:36,200 --> 0:12:38,960
called and so you basically don't have

316
0:12:38,960 --> 0:12:40,340
to think of any of those complexities

317
0:12:40,340 --> 0:12:42,260
that you have in other systems when you

318
0:12:42,260 --> 0:12:43,760
want information in a file you put it

319
0:12:43,760 --> 0:12:45,230
there when you want it back you get it

320
0:12:45,230 --> 0:12:46,460
out again and you don't have to think

321
0:12:46,460 --> 0:12:49,160
about size or number of Records or

322
0:12:49,160 --> 0:12:50,570
number of fields or anything like that

323
0:12:50,570 --> 0:12:52,490
unless it's really germane to your

324
0:12:52,490 --> 0:12:54,740
program for most purposes it's utterly

325
0:12:54,740 --> 0:12:57,290
irrelevant a file is simply a sequence

326
0:12:57,290 --> 0:13:00,140
of bytes its main attribute is its size

327
0:13:00,140 --> 0:13:02,600
by contrast and more conventional

328
0:13:02,600 --> 0:13:05,960
systems file has dozen or so attributes

329
0:13:05,960 --> 0:13:08,660
to specify or create a file it takes

330
0:13:08,660 --> 0:13:11,210
endless amounts of chitchat if you want

331
0:13:11,210 --> 0:13:13,610
a UNIX system file you simply ask for a

332
0:13:13,610 --> 0:13:14,810
file and you can use it interchangeably

333
0:13:14,810 --> 0:13:17,900
wherever you want to file the UNIX

334
0:13:17,900 --> 0:13:20,170
system consists of a hierarchy of

335
0:13:20,170 --> 0:13:22,970
directories which a directory is simply

336
0:13:22,970 --> 0:13:25,220
a file that contains the names of either

337
0:13:25,220 --> 0:13:28,100
other directories or files and this

338
0:13:28,100 --> 0:13:30,920
whole thing goes on recursively when you

339
0:13:30,920 --> 0:13:32,780
log into a UNIX system you normally are

340
0:13:32,780 --> 0:13:34,070
sitting in a place that's called your

341
0:13:34,070 --> 0:13:36,050
home directory or users directory and I

342
0:13:36,050 --> 0:13:38,330
can say TWD which means print the name

343
0:13:38,330 --> 0:13:39,890
of my working directory and it'll tell

344
0:13:39,890 --> 0:13:41,480
me where I am it says at the moment that

345
0:13:41,480 --> 0:13:44,420
I mean user bwk that's where I start

346
0:13:44,420 --> 0:13:48,200
when I log in now I can go up a level in

347
0:13:48,200 --> 0:13:49,230
that I can

348
0:13:49,230 --> 0:13:52,380
change to parent level and now if I

349
0:13:52,380 --> 0:13:54,150
print my working directory I'm in slash

350
0:13:54,150 --> 0:13:56,400
user and I can go up one more level to

351
0:13:56,400 --> 0:13:58,830
the root of the whole file system let me

352
0:13:58,830 --> 0:14:02,070
go back down to BW k and I can list the

353
0:14:02,070 --> 0:14:03,930
direct the files that I have in that

354
0:14:03,930 --> 0:14:08,520
directory and I find there among other

355
0:14:08,520 --> 0:14:12,390
things a directory called TV and I can

356
0:14:12,390 --> 0:14:13,710
list the files that are there and I'll

357
0:14:13,710 --> 0:14:15,960
find among other things the sentence

358
0:14:15,960 --> 0:14:17,940
that we printed in a spelling mistake

359
0:14:17,940 --> 0:14:20,160
finding program they look at that and

360
0:14:20,160 --> 0:14:22,920
sure enough there it is so as you can

361
0:14:22,920 --> 0:14:25,350
see the file system hierarchy makes it

362
0:14:25,350 --> 0:14:27,270
possible for users to organize

363
0:14:27,270 --> 0:14:29,610
information into its natural grouping

364
0:14:29,610 --> 0:14:32,610
and to go up or down and find things

365
0:14:32,610 --> 0:14:35,670
quickly and easily the UNIX system

366
0:14:35,670 --> 0:14:37,950
interface for most people is through

367
0:14:37,950 --> 0:14:39,930
program called the shell or the command

368
0:14:39,930 --> 0:14:41,490
interpreter basically it's simply a

369
0:14:41,490 --> 0:14:44,630
program that watches what you type and

370
0:14:44,630 --> 0:14:48,270
treats it as requests to run particular

371
0:14:48,270 --> 0:14:50,810
programs now there's nothing magic about

372
0:14:50,810 --> 0:14:53,280
running programs the programs that you

373
0:14:53,280 --> 0:14:55,590
run are actually just the names of files

374
0:14:55,590 --> 0:14:58,320
in the file system the shell searches in

375
0:14:58,320 --> 0:14:59,970
the file system in a particular way to

376
0:14:59,970 --> 0:15:02,430
find a file whose name is the name of

377
0:15:02,430 --> 0:15:03,540
the program that you think you're

378
0:15:03,540 --> 0:15:06,410
running and it goes and executes it and

379
0:15:06,410 --> 0:15:10,170
in fact it's not possible for you as a

380
0:15:10,170 --> 0:15:13,110
user just by executing a program to tell

381
0:15:13,110 --> 0:15:15,540
how that particular program has been

382
0:15:15,540 --> 0:15:17,040
implemented for example it might have

383
0:15:17,040 --> 0:15:18,450
been written in a language like Fortran

384
0:15:18,450 --> 0:15:20,970
or C or it may have in fact been written

385
0:15:20,970 --> 0:15:23,520
as something like the spell program that

386
0:15:23,520 --> 0:15:24,780
we talked about earlier which is a

387
0:15:24,780 --> 0:15:27,120
combination of other programs stuck

388
0:15:27,120 --> 0:15:29,520
together with pipes or some similar

389
0:15:29,520 --> 0:15:33,890
thing and all put in a single file as a

390
0:15:33,890 --> 0:15:36,980
shell sequence or sequence of commands

391
0:15:36,980 --> 0:15:40,200
what Brian did earlier was he typed all

392
0:15:40,200 --> 0:15:42,740
the commands the the five program names

393
0:15:42,740 --> 0:15:45,780
for his spelling checker on one line

394
0:15:45,780 --> 0:15:48,630
using the pipeline facilities that's

395
0:15:48,630 --> 0:15:50,820
nice except that you may want to check

396
0:15:50,820 --> 0:15:54,270
documents often and you don't want to

397
0:15:54,270 --> 0:15:55,740
have to type that long sequence of

398
0:15:55,740 --> 0:15:58,560
commands so it's possible to put all of

399
0:15:58,560 --> 0:16:00,930
these commands in a file and tell the

400
0:16:00,930 --> 0:16:02,070
shell when

401
0:16:02,070 --> 0:16:04,769
I type the name of that file I want you

402
0:16:04,769 --> 0:16:06,540
to execute the commands that are inside

403
0:16:06,540 --> 0:16:08,880
that file let me show you an example of

404
0:16:08,880 --> 0:16:12,660
this we have a program called spline

405
0:16:12,660 --> 0:16:17,970
which fits curves to a set of data

406
0:16:17,970 --> 0:16:19,680
points and I've got a set of five data

407
0:16:19,680 --> 0:16:21,420
points that we're going to see what the

408
0:16:21,420 --> 0:16:23,790
curve looks like I'm going to run spline

409
0:16:23,790 --> 0:16:28,019
through a program that turns this into

410
0:16:28,019 --> 0:16:30,600
graphics called graph and I'm going to

411
0:16:30,600 --> 0:16
run that through a special program that

412
0:16 --> 0:16:35,779
turns the graphic language into

413
0:16:35,779 --> 0:16:38,339
something specific for this terminal I

414
0:16:38,339 --> 0:16:42,990
only need to type plot and data because

415
0:16:42,990 --> 0:16:45,300
inside the file plot is the string of

416
0:16:45,300 --> 0:16:47,069
commands and here is a result of

417
0:16:47,069 --> 0:16:48,720
plotting those five data points on this

418
0:16:48,720 --> 0:16:51,660
particular terminal the ability to put

419
0:16:51,660 --> 0:16:54,810
commands in files and only have to type

420
0:16:54,810 --> 0:16:56,699
the file name to get these commands

421
0:16:56,699 --> 0:17:00,209
executed makes the computing business a

422
0:17:00,209 --> 0:17:02,339
lot easier often you're doing things

423
0:17:02,339 --> 0:17:04,380
that are repetitive and you don't want

424
0:17:04,380 --> 0:17:06,809
to have to type long lists of things

425
0:17:06,809 --> 0:17:08,850
this makes our life much easier and

426
0:17:08,850 --> 0:17:11,069
allows us to tailor our environment for

427
0:17:11,069 --> 0:17:13,980
the way we want to work another nice

428
0:17:13,980 --> 0:17:15,419
feature of the UNIX programming

429
0:17:15,419 --> 0:17:17,790
environment is the concept of input

430
0:17:17,790 --> 0:17:21,120
output redirection normally when you

431
0:17:21,120 --> 0:17:23,429
type a command the output from it goes

432
0:17:23,429 --> 0:17:25,439
to your terminal and the input comes

433
0:17:25,439 --> 0:17:26,750
from your keyboard

434
0:17:26,750 --> 0:17:29,010
however the shell can be told by a

435
0:17:29,010 --> 0:17:31,409
simple notation that when you run a

436
0:17:31,409 --> 0:17:32,850
program you wish the output to be

437
0:17:32,850 --> 0:17:35,190
directed into a file or that the input

438
0:17:35,190 --> 0:17:37,830
be taken from a file for example to

439
0:17:37,830 --> 0:17:39,840
print the output of my spelling program

440
0:17:39,840 --> 0:17:42,120
on the line printer instead of putting

441
0:17:42,120 --> 0:17:44,220
it on my terminal all I have to do is

442
0:17:44,220 --> 0:17:47,940
say my spell sentence greater than

443
0:17:47,940 --> 0:17:50,970
device line printer rather than my spell

444
0:17:50,970 --> 0:17:52,890
sentence and the output goes into the

445
0:17:52,890 --> 0:17:55,320
file what looks like a file except that

446
0:17:55,320 --> 0:17:56,730
it's actually a file that causes the

447
0:17:56,730 --> 0:17:58,409
line printer to spring into action and

448
0:17:58,409 --> 0:18:01,200
print my three or four spelling mistakes

449
0:18:01,200 --> 0:18:04,520
on the line printer on many systems

450
0:18:04,520 --> 0:18:08,010
redirection of input and output is

451
0:18:08,010 --> 0:18:09,419
literally impossible because the

452
0:18:09,419 --> 0:18:11,610
programs have wired into them the notion

453
0:18:11,610 --> 0:18:13,950
that they have to read or write the

454
0:18:13,950 --> 0:18:15,540
user's terminal and there's simply no

455
0:18:15,540 --> 0:18:15,960
way

456
0:18:15,960 --> 0:18:17,429
to convince them otherwise they'd have

457
0:18:17,429 --> 0:18:20,610
to do that here that is not the case

458
0:18:20,610 --> 0:18:23,039
here any program can have its input or

459
0:18:23,039 --> 0:18:25,409
output redirected because the input and

460
0:18:25,409 --> 0:18:27,210
output redirection is handled not by the

461
0:18:27,210 --> 0:18:29,190
individual program but by the shell and

462
0:18:29,190 --> 0:18:31,049
so that way it applies to all programs

463
0:18:31,049 --> 0:18:33,690
without any exception at all and in fact

464
0:18:33,690 --> 0:18:35,309
this goes a little further than you

465
0:18:35,309 --> 0:18:38,700
might expect because not only are parts

466
0:18:38,700 --> 0:18:41,039
of the disk files as they are in other

467
0:18:41,039 --> 0:18:45,240
systems but in addition the i/o devices

468
0:18:45,240 --> 0:18:47,279
the peripheral devices connected to the

469
0:18:47,279 --> 0:18:49,499
computer are also files in the file

470
0:18:49,499 --> 0:18:51,299
system for example the line printer and

471
0:18:51,299 --> 0:18:52,799
the tape drive and even the thing that

472
0:18:52,799 --> 0:18:55,590
dials telephone numbers are all devices

473
0:18:55,590 --> 0:18:57,330
in the file system in the same program

474
0:18:57,330 --> 0:18:59,759
that will copy information from one disk

475
0:18:59,759 --> 0:19:01,769
file to another disk file will also copy

476
0:19:01,769 --> 0:19:04,289
information from a disk file to the line

477
0:19:04,289 --> 0:19:06,119
printer or from the magnetic tape drive

478
0:19:06,119 --> 0:19:08,249
to the printer the same program exactly

479
0:19:08,249 --> 0:19:12,090
a good operating system is easiest for

480
0:19:12,090 --> 0:19:14,970
programmer to use if the programming

481
0:19:14,970 --> 0:19:17,309
language fits with the style of the

482
0:19:17,309 --> 0:19:19,799
system so along the way in the course of

483
0:19:19,799 --> 0:19:21,869
the unit systems development Dennis

484
0:19:21,869 --> 0:19:24,509
Ritchie created the C language C is a

485
0:19:24,509 --> 0:19:27,029
very nice high-level language with many

486
0:19:27,029 --> 0:19:29,460
of the modern programming constructs in

487
0:19:29,460 --> 0:19:32,039
it the thing that's very important about

488
0:19:32,039 --> 0:19:35,610
it is that it lets you avoid the details

489
0:19:35,610 --> 0:19:38,369
of the machine when you want to but when

490
0:19:38,369 --> 0:19:40,679
you need to and sometimes when you're

491
0:19:40,679 --> 0:19:42,299
writing an operating system you really

492
0:19:42,299 --> 0:19:45,149
do need to you can get at the details of

493
0:19:45,149 --> 0:19:47,549
the machine and control everything but

494
0:19:47,549 --> 0:19:49,080
you're not forced to do that and that's

495
0:19:49,080 --> 0:19:51,419
important because that means you can

496
0:19:51,419 --> 0:19:53,159
write operating systems in this language

497
0:19:53,159 --> 0:19:55,919
and still have something that can be

498
0:19:55,919 --> 0:19:58,590
portable to other machines the UNIX

499
0:19:58,590 --> 0:20:00,299
system has been moved to many many

500
0:20:00,299 --> 0:20:03,029
different kinds of computers again that

501
0:20:03,029 --> 0:20:05,460
means that people can ignore the details

502
0:20:05,460 --> 0:20:09,299
of what a machine is underneath and get

503
0:20:09,299 --> 0:20:13,350
on with their job now so at that level C

504
0:20:13,350 --> 0:20:15,659
is by far the favorite language at the

505
0:20:15,659 --> 0:20:17,549
next level the shell programming

506
0:20:17,549 --> 0:20:20,460
language is very popular back on some

507
0:20:20,460 --> 0:20:22,440
machines people find that the shell

508
0:20:22,440 --> 0:20:24,330
meets all of their programming needs

509
0:20:24,330 --> 0:20:26,789
they are writing lots of procedures to

510
0:20:26,789 --> 0:20:28,799
help them manage their work they don't

511
0:20:28,799 --> 0:20:29,789
even have to

512
0:20:29,789 --> 0:20:33,899
go to a language at the level of see as

513
0:20:33,899 --> 0:20:36,359
it happens though because the system is

514
0:20:36,359 --> 0:20:38,299
such a pleasant programming environment

515
0:20:38,299 --> 0:20:40,679
programmers all over the world have

516
0:20:40,679 --> 0:20:43,859
imported or added their own languages so

517
0:20:43,859 --> 0:20:46,440
for instance you can find Fortran Algol

518
0:20:46,440 --> 0:20:50,460
Lisp basic fact almost any language you

519
0:20:50,460 --> 0:20:53,009
can think of exists on some UNIX system

520
0:20:53,009 --> 0:20:54,570
somewhere what's important about the

521
0:20:54,570 --> 0:20:56,789
unique system is not so much what Ricci

522
0:20:56,789 --> 0:20:59,190
and Thompson put into it as what they

523
0:20:59,190 --> 0:21:01,769
were able to leave out of it rather than

524
0:21:01,769 --> 0:21:03,779
produce a large number of primitives

525
0:21:03,779 --> 0:21:07,349
each one complex they were able to

526
0:21:07,349 --> 0:21:09,330
choose a small number of simple

527
0:21:09,330 --> 0:21:11,519
primitives which could be fitted

528
0:21:11,519 --> 0:21:14,070
naturally together to accomplish complex

529
0:21:14,070 --> 0:21:16,229
tasks this structure of the operating

530
0:21:16,229 --> 0:21:20,190
system makes it natural and easy for

531
0:21:20,190 --> 0:21:21,809
people who create applications to

532
0:21:21,809 --> 0:21:24,019
produce applications in that same style

533
0:21:24,019 --> 0:21:26,970
for example as the scale of integration

534
0:21:26,970 --> 0:21:29,700
of silicon circuits gets ever larger we

535
0:21:29,700 --> 0:21:31,289
find it necessary to have more and more

536
0:21:31,289 --> 0:21:33,359
sophisticated design aids to help people

537
0:21:33,359 --> 0:21:35,460
create large-scale integrated circuits

538
0:21:35,460 --> 0:21:37,979
our existing design aids are advanced

539
0:21:37,979 --> 0:21:40,320
and effective but advances in VLSI

540
0:21:40,320 --> 0:21:42,210
create a need for even better tools

541
0:21:42,210 --> 0:21:44,340
rather than produce those tools in the

542
0:21:44,340 --> 0:21:47,729
form of one humongous program designed

543
0:21:47,729 --> 0:21:50,519
to do everything the people here have

544
0:21:50,519 --> 0:21:52,679
been producing small packages each

545
0:21:52,679 --> 0:21:54,840
designed to do some individual function

546
0:21:54,840 --> 0:21:56,220
that's helpful in the design of

547
0:21:56,220 --> 0:21:58,679
integrated circuits then these

548
0:21:58,679 --> 0:22:00,809
individual packages can be combined

549
0:22:00,809 --> 0:22:03,359
using shell procedures to design a part

550
0:22:03,359 --> 0:22:05,820
of a circuit or a circuit and the parts

551
0:22:05,820 --> 0:22:07,559
of a circuit can be combined to make a

552
0:22:07,559 --> 0:22:11,009
whole circuit Steve Johnson is one of

553
0:22:11,009 --> 0:22:12,389
the people who has been involved in this

554
0:22:12,389 --> 0:22:14,700
effort he is currently working on a

555
0:22:14,700 --> 0:22:16,590
program called Elgin which takes boolean

556
0:22:16,590 --> 0:22:19,019
equations as input and produces logic

557
0:22:19,019 --> 0:22:21,749
circuit designs as output because tool

558
0:22:21,749 --> 0:22:24,359
building is such a way of life on the

559
0:22:24,359 --> 0:22:26,220
UNIX system over the years we've

560
0:22:26,220 --> 0:22:28,559
developed tools that actually help us

561
0:22:28,559 --> 0:22:31,950
make other tools these involve things

562
0:22:31,950 --> 0:22:35,220
like parser generators lexical analyser

563
0:22:35,220 --> 0:22:38,639
generators and other programs that help

564
0:22:38,639 --> 0:22:44,220
us organize and develop tools these

565
0:22:44,220 --> 0:22:45,480
tools have been used in the development

566
0:22:45,480 --> 0:22:48,259
of L gen and many other applications

567
0:22:48,259 --> 0:22:52,830
here we see the boolean equations for a

568
0:22:52,830 --> 0:22:57,419
simple matter down here we have the

569
0:22:57,419 --> 0:23:08,140
equations for the carryout and the sum

570
0:23:08,140 --> 0:23:10,600
in the middle we have some descriptions

571
0:23:10,600 --> 0:23:13,840
as to how we would like the cell to be

572
0:23:13,840 --> 0:23:16,809
laid out geometrically see we would like

573
0:23:16,809 --> 0:23:20,919
the two inputs on the left side the

574
0:23:20,919 --> 0:23:24,399
carry in on the bottom the carryout on

575
0:23:24,399 --> 0:23:28,980
the top and the output on the right side

576
0:23:28,980 --> 0:23:31,990
the input equations first have to be

577
0:23:31,990 --> 0:23:34,630
processed so that they can be more

578
0:23:34,630 --> 0:23:36,970
easily represented in silicon this

579
0:23:36,970 --> 0:23:39,309
process is very similar to recognizing

580
0:23:39,309 --> 0:23:41,679
common sub-expressions in the input of a

581
0:23:41,679 --> 0:23:45,250
compiler input language the boolean

582
0:23:45,250 --> 0:23:48,220
equations are read and processed by a

583
0:23:48,220 --> 0:23:51,220
program called yak which was originally

584
0:23:51,220 --> 0:23:54,909
developed to help us build compilers but

585
0:23:54,909 --> 0:23:56,529
has in fact been used in a large number

586
0:23:56,529 --> 0:23:59,820
of application programs as well yak is

587
0:23:59,820 --> 0:24:06,210
based on the theory of lalr 1 parsing

588
0:24:06,210 --> 0:24:08,559
represents it builds a small finite

589
0:24:08,559 --> 0:24:11,590
state machine which is able to control

590
0:24:11,590 --> 0:24:14,679
the actions of the program which reads

591
0:24:14,679 --> 0:24:19,169
the input detect errors accurately and

592
0:24:19,169 --> 0:24:21,789
structure the input in such a way that

593
0:24:21,789 --> 0:24:23,669
the program can then go ahead and

594
0:24:23,669 --> 0:24:28,779
perform its operations on it after these

595
0:24:28,779 --> 0:24:30,460
equations have been processed

596
0:24:30,460 --> 0:24:33,220
it's then necessary to worry about the

597
0:24:33,220 --> 0:24:38,200
geometric layout of the circuit this is

598
0:24:38,200 --> 0:24:41,200
done in the next 2 portions of el jem

599
0:24:41,200 --> 0:24:44,710
the first program worries about the

600
0:24:44,710 --> 0:24:50,289
ordering of these columns it uses a

601
0:24:50,289 --> 0:24:53,610
technique called graph partitioning to

602
0:24:53,610 --> 0:24:56,139
attempt to iteratively come up with a

603
0:24:56,139 --> 0:24:58,210
good solution to what is in fact an

604
0:24:58,210 --> 0:25:01,440
extremely difficult problem in theory

605
0:25:01,440 --> 0:25:04,659
after the columns have been ordered then

606
0:25:04,659 --> 0:25:07,840
the tracks where the signals run are

607
0:25:07,840 --> 0:25:11,309
laid out as well by another program and

608
0:25:11,309 --> 0:25:14,950
finally in some sense we now have the

609
0:25:14,950 --> 0:25:17,110
circuit designed and it's simply a

610
0:25:17,110 --> 0:25
question of realizing it with the

611
0:25 --> 0:25:20,320
particular rules

612
0:25:20,320 --> 0:25:24,190
for our fabrication process and that is

613
0:25:24,190 --> 0:25:27,910
done by a fourth program so once again

614
0:25:27,910 --> 0:25:31,030
we have an example of taking a very

615
0:25:31,030 --> 0:25:33,990
complex problem dividing it into pieces

616
0:25:33,990 --> 0:25:36,640
representing each piece with a separate

617
0:25:36,640 --> 0:25:39,880
program and then using the facilities of

618
0:25:39,880 --> 0:25:41,680
the UNIX system to glue the pieces

619
0:25:41,680 --> 0:25:45,990
together into a coherent whole again

620
0:25:45,990 --> 0:25:47,920
computing is going to be more and more

621
0:25:47,920 --> 0:25:49,810
inner woven with people's lives as the

622
0:25:49,810 --> 0:25:53,020
years go by so computer technology is

623
0:25:53,020 --> 0:25:55,150
going to have to evolve to be easier for

624
0:25:55,150 --> 0:25:58,300
people to use the unit system is not the

625
0:25:58,300 --> 0:26:00,280
end of the road in this regard but I

626
0:26:00,280 --> 0:26:41,080
think it's a good step along the way

627
0:26:41,080 --> 0:27:10,370
you

628
0:27:10,370 --> 0:27:17,340
you

629
0:27:17,340 --> 0:27:19,400
you

